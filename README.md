Задание №1

Уровень 1. Проектирование

    Итоговый ответ Уровня 1
        Суммируем !Выводы (детализация представлена ниже):
            1. На основе требований и допущений фреймворком был выбран Module Federation
            2. Выделяем следующие микрофронтенды:
                microfrontend_cards
                microfrontend_users
                microfrontend_auth
        
        Используемые требования и допущения:
        1. Требуется использовать принцип экспорта/импорта компонентов между модулями
        2. Необходимо дать возможность командам разработки использовать динамический обмен кодом между модулями, что позволит гибко управлять зависимостями и избежать дублирование кода
        3. Module Federation использовался в примере лабораторной работы, что также добавило **команде разработки** опыта взаимодействия с данным фреймворком в сравнении с SPA.
    
!Детализация решения Уровня 1 по выделению микрофронтендов

    Изучим структуры исходного репозитория
    > Dockerfile.frontend:
        Видим запуск установки сервисов по тестированию и копирование package.json, package-lock.json. Также видим, что используются различные менеджеры пакетов (NPM для backend и Yarn для frontend). Другие зависимости отсутствуют.
        Вывод: дополнительные условия для проектирования микрофронтендов не возникают.

    > compose.yaml
        Проверим сервисы frontend-test и frontend. В сервисе frontend видим зависимость от состояния сервиса backend (service_healthy, вызывающий healthcheck.js). Другие зависимости отсутствуют.
        Вывод: дополнительные условия для проектирования микрофронтендов не возникают.

    > frontend/package.json
        В разделе dependencies отсутствуют модули, которые необходимо учесть при проектировании микрофронтендов.
        В разделе scripts видим нестандартный скрипт "test:microfrontend": "npx jest ./index.spec.js", который используется для тестирования работоспособности микрофронтендов. Изучим "index.spec.js" видим, что существует проверка на наличие директорий, которые в названии имеют слово microfrontend
        !Вывод: добавляем слово microfrontend в имя каталогов/проектов, содержащих код микрофронтендов.

    > frontend/package-lock.json
        Не накладывает дополнительные условия для проектирования микрофронтендов

    > Код в директории frontend/public/
        Не накладывает дополнительные условия для проектирования микрофронтендов

    > frontend/src/index.js
        Принимаем решение о том, что текущее приложение будет являться корневым для других микрофронтов и вызывать их код. index.js переиспользуем в новой архитектуре
        Вывод: дополнительные условия для проектирования микрофронтендов не возникают.
    
    > frontend/src/index.css
        Видим структуру вызовов css файлов из блоков приложения.
        !Вывод: При выделении микрофронтендов, необходимо учитывать css зависимости из директории frontend/src/blocks

    > frontend/src/serviceWorker.js, setupTests.js
        Не накладывают дополнительные условия для проектирования микрофронтендов
    
    > frontend/src/utils/api.js
        Изучим методы getAppInfo(), getCardList(), addCard(), removeCard(), getUserInfo(), setUserInfo(), setUserAvatar(), changeLikeCardStatus().
        Видим потенциал для формирования отдельных микрофронтендов, которые объединят в себе следующие методы:
        1. Микрофронтенд работы с карточками изображений microfrontend_cards, объединяет методы getCardList(), addCard(), removeCard(), changeLikeCardStatus()
        2. Микрофронтенд работы с профилем клиента microfrontend_users, объединяет методы  getUserInfo(), setUserInfo(), setUserAvatar()
        
        Отдельный микрофронтенд для учета лайков создавать нецелесообразно по причине сильной связности лайков и карточки изображений (вывод сделан на основе backend/src/models/card.ts).
        Сервис getAppInfo() оставляем в корневом приложении.
        !Вывод: создаем следующие микрофронтенды microfrontend_cards, microfrontend_users
    
    > frontend/src/utils/auth.js
        Изучим функции регистрации, авторизации и проверки валидности токена пользователя. Видим потенциал для формирования единого микрофронтенда, куда войдут эти функции.
        !Вывод: создаем микрофронтенд microfrontend_auth

    > frontend/src/contexts/CurrentUserContext.js
        Функцию export const CurrentUserContext оставляем на уровне корневого приложения для передачи контекста о текущем пользователе.
        Вызов библиотеки состояния import { useContext } from 'react' отсутствует.
        Вывод: дополнительные условия для проектирования микрофронтендов не возникают.

    > frontend/src/components/AddPlacePopup.js
        Функция AddPlacePopup() используется для создания всплывающего окна, которое позволяет пользователям добавлять новое место. Т.к. это всплывающее окно отвечает за добавление новой карточки, то мы переносим данный функционал в соответствующий микрофронтенд.
        !Вывод: функционал переносится в микрофронтенд работы с карточками изображений microfrontend_cards. PopupWithForm.js оставляем на уровне корневого приложения, см. ADR ниже.

    > frontend/src/components/App.js
        #данный блок заполнялся последним с учетом использованием проанализированной информации и может ссылаться на эти выводы.

        Изучим зависимости блока import. Видим, что дерево файлов проекта соответствует перечню import. Все вызовы были учтены в анализе.

        Изучим функции App.js
        Предложение по переносу функциональности в соответствующие фронтенды:
        1. microfrontend_cards
            handleAddPlaceClick();
            handleCardClick();
            handleCardLike();
            handleAddPlaceSubmit();
            handleCardDelete();
        2. microfrontend_users
            handleEditProfileClick();
            handleEditAvatarClick();
            handleUpdateAvatar();
        3. microfrontend_auth
            onRegister();
            onLogin();
            onSignOut();

        !Вывод: учесть перенос функциональности в микрофронтенды

    > frontend/src/components/Card.js
        Функция Card() используется для отображения карточки изображения, нажатия лайка и удаления карточки.
        !Вывод: функционал переносится в микрофронтенд работы с карточками изображений microfrontend_cards. CurrentUserContext.js оставляем на уровне корневого приложения

    > frontend/src/components/EditAvatarPopup.js
        Функция EditAvatarPopup() используется для изменения аватара в профайле пользователя.
        !Вывод: функционал переносится в микрофронтенд работы с профилем клиента microfrontend_users. PopupWithForm.js оставляем на уровне корневого приложения, см. ADR ниже.
    
    > frontend/src/components/EditProfilePopup.js
        Функция EditProfilePopup() используется для редактирования профайла пользователя в части имени и описания с дальнейшим применением изменений. PopupWithForm.js оставляем на уровне корневого приложения, см. ADR ниже. CurrentUserContext.js аналогично.
        !Вывод: функционал переносится в микрофронтенд работы с профилем клиента microfrontend_users

    > frontend/src/components/Footer.js
        Функция Footer() отвечает за отображение нижнего блока с копирайтом на главной странице сайта. Функциональность оставляем в корневом приложении.
        Вывод: дополнительные условия для проектирования микрофронтендов не возникают.

    > frontend/src/components/Header.js
        Функция Header() отвечает за отображение шапки на странице, которая включает в себя логотип, ссылки на регистрацию и вход, а также кнопку выхода. Функциональность оставляем в корневом приложении
        Вывод: дополнительные условия для проектирования микрофронтендов не возникают.

    > frontend/src/components/ImagePopup.js
        Функция ImagePopup() используется для для отображения всплывающего окна с карточкой изображения.
        !Вывод: функционал переносится в микрофронтенд работы с профилем клиента microfrontend_cards

    > frontend/src/components/InfoTooltip.js
        Функция InfoTooltip() используется для отображения всплывающего окна с информацией о статусе регистрации или ошибки.
        !Вывод: функционал переносится в микрофронтенд работы с профилем клиента microfrontend_auth. Учесть перенос images/success-icon.svg, images/error-icon.svg
    
    > frontend/src/components/Login.js
        Функция Login() представляет собой форму для входа в систему. Она принимает вводы пользователя, такие как электронная почта и пароль, и отправляет их на сервер для верификации и авторизации.
        !Вывод: функционал переносится в микрофронтенд работы с профилем клиента microfrontend_auth. Учесть перенос /blocks/login/login.css

    > frontend/src/components/Main.js
        Функция Main() объединяет в себе представление функционала для корневого приложения.
        Вывод: оставляем данный файл для корневого приложения

    > frontend/src/components/PopupWithForm.js
        Функция PopupWithForm() используется для создания всплывкого окна с формой, где пользователи могут заполнять форму и сохранять её содержимое. Данная функция используется в других функциональностях, которые решено вывести в отдельные фронтенды, поэтому вызываем ее оттуда.
        ADR: с целью минимизации дублирования кода принимается ахритектурное решение продолжить разработку PopupWithForm() на уровне корневого приложения, без дублирования для каждого фронтенда. Исключение - *.css файлы для корректной визауализации объектов.
        Вывод: оставляем данный файл для корневого приложения

    > frontend/src/components/ProtectedRoute.js
        Функция ProtectedRoute() используется для создания защищенных маршрутов в приложении, предоставляю доступ к определенным страницам только после успешной аутентификации. Т.к. сервис управляет всеми переходами, то мы оставляем его в общей директории
        Вывод: оставляем данный файл для корневого приложения

    > frontend/src/components/Register.js   
        Данный компонент предназначен для регистрации пользователей
        !Вывод: функционал переносится в микрофронтенд работы с профилем клиента microfrontend_auth
            

    

Уровень 2. Планирование изменений

Итоговый ответ Уровня 2

        1. Дополним микрофронтенды зависимостями из блоков frontend/src/blocks и frontend/src/images
            Для этого для каждого подкаталога blocks проведем поиск упоминания в файлах исходного решения.
        2. Переносим в микрофронтенды !Выводы из первого уровня задания, дополняем blocks из пункта выше
            microfrontend_cards
                App.js
                    handleAddPlaceClick(), handleCardClick(), handleCardLike(), handleAddPlaceSubmit(), handleCardDelete()
                blocks
                    card/..
                    content/..
                    places/..
                    popup/..
                сomponents
                    AddPlacePopup.js
                    Card.js
                    ImagePopup.js
                utils
                    api.js
                        getCardList(), addCard(), removeCard(), changeLikeCardStatus()
            microfrontend_users
                App.js
                    handleEditProfileClick(), handleEditAvatarClick(), handleUpdateAvatar()
                blocks
                    content/..
                    popup/..
                сomponents
                    EditAvatarPopup.js
                    EditProfilePopup.js
                utils
                    api.js
                        getUserInfo(), setUserInfo(), setUserAvatar()
            microfrontend_auth
                App.js
                    onRegister(),onLogin(), onSignOut()
                сomponents
                    InfoTooltip.js
                    Login.js
                    Register.js
                blocks
                    auth-form/..
                    content/..
                    header/..
                    popup/..
                    profile/..
                    login
                        login.css
                images
                    success-icon.svg
                    error-icon.svg
                utils
                    auth.js
                        onRegister(), onLogin(), onSignOut()
        3. Создадим с помощью npx create-mf-app директории для наших фронтендов
        4. Сформируем структуру из пункта №2 (код не испралялся, уровень 3 не выполнялся)
        5. Выполним pull в ветку sprint_1



Уровень 3. Запуск готового кода
    > Задание не выполнялось


Задание №2
    
    Ссылка на выполненное задание:
    Файл arch_task2_efremov_denis_v1.0 находится в каталоге task#2 ветки sprint_1